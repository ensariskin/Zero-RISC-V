%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 3.2 FETCH AŞAMASI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Fetch Aşaması}\label{sec:fetch}

Fetch aşaması, süperölçekli işlemcinin ilk pipeline aşaması olup, bellekten komutların getirilmesi, dal tahmin işlemlerinin gerçekleştirilmesi ve getirilen komutların sonraki aşamalar için tamponlanmasından sorumludur. Tasarlanan işlemcide fetch aşaması, üç ana bileşenden oluşmaktadır: Multi-Fetch birimi, dal tahmin sistemi ve komut arabelleği.

\subsection{Multi-Fetch Birimi}\label{subsec:multi_fetch}

Multi-Fetch birimi, her çevrimde bellekten birden fazla komutu paralel olarak getirerek komut seviyesi paralelliğinden (ILP) yararlanmayı mümkün kılar \cite{shen_lipasti}. Tasarlanan sistemde, beş komut slotu desteklenmekte olup, dal tahminlerinin doğruluğuna bağlı olarak geçerli komut sayısı dinamik olarak belirlenmektedir.

\subsubsection{Paralel komut getirme}\label{subsubsec:parallel_fetch}

Paralel komut getirme mekanizması, ardışık beş bellek adresine eş zamanlı erişim sağlayarak yüksek bant genişliği elde edilmesini mümkün kılar. Her bir komut slotu için ayrı adres çıkışları ve komut girişleri bulunmaktadır:

\begin{itemize}
    \item \texttt{inst\_addr\_0} ile \texttt{inst\_addr\_4}: Beş ayrı bellek adres çıkışı
    \item \texttt{instruction\_i\_0} ile \texttt{instruction\_i\_4}: Beş ayrı komut girişi
\end{itemize}

Komutların geçerliliği, dal tahmin sonuçlarına bağlı olarak belirlenir. Eğer bir dal komutu "alınacak" (taken) olarak tahmin edilirse, bu daldan sonraki komutlar otomatik olarak geçersiz işaretlenir. Bu mekanizma, yanlış yol komutlarının pipeline'a girmesini engeller:

\begin{equation}\label{eq:block_logic}
block\_n = (jump_{n-1}) \lor block_{n-1}
\end{equation}

Denklem \ref{eq:block_logic}'da görüldüğü gibi, herhangi bir slottaki dal tahmininin "alınacak" olması, sonraki tüm slotların bloklanmasına neden olur.

\subsubsection{Erken aşama acil değer çözümleyici}\label{subsubsec:early_decode}

Dal hedef adreslerinin erken hesaplanabilmesi için her komut slotuna \texttt{early\_stage\_immediate\_decoder} modülü eklenmiştir. Bu modüller, tam komut çözümleme işlemi beklenmeden acil değerleri (immediate values) çıkarır. Bu yaklaşım, dal hedef hesaplamasının tek çevrimde tamamlanmasını sağlar.

Erken çözümleme, RISC-V komut formatlarının düzenli yapısından yararlanmaktadır \cite{riscv_spec}. B-tipi dallanma komutları ve J-tipi atlama komutları için acil değerler, komutun belirli bit alanlarından doğrudan çıkarılır ve işaret genişletmesi uygulanır.

\subsubsection{Program sayacı hesaplama}\label{subsubsec:pc_ctrl}

Program sayacı (PC) kontrol birimi (\texttt{pc\_ctrl\_super}), bir sonraki getirme adresini belirlemekten sorumludur. Bu birim, aşağıdaki girişleri değerlendirerek PC değerini hesaplar:

\begin{enumerate}
    \item \textbf{Sıralı ilerleme:} Dal tahmini yapılmamışsa veya dal "alınmayacak" olarak tahmin edilmişse, PC değeri 4 arttırılır (32-bit komutlar için).
    \item \textbf{Dal tahmini:} Dal "alınacak" olarak tahmin edilmişse, PC hedef adrese atlar.
    \item \textbf{Yanlış tahmin düzeltmesi:} Execute aşamasından yanlış tahmin sinyali gelirse, PC doğru adrese yönlendirilir.
\end{enumerate}

PC hesaplama mantığı aşağıdaki gibi ifade edilebilir:

\begin{equation}\label{eq:pc_next}
PC_{next} = \begin{cases}
correct\_pc & \text{eğer } misprediction = 1 \\
PC + imm & \text{eğer } branch\_taken = 1 \\
PC + 20 & \text{aksi halde (5 komut için)}
\end{cases}
\end{equation}

%------------------------------------------------------------------------

\subsection{Dal Tahmin Sistemi}\label{subsec:branch_pred}

Dal tahmin sistemi, kontrol akışı değişikliklerinin erken tespit edilmesini ve yüksek doğrulukla tahmin edilmesini sağlar. Yanlış tahminler, pipeline'ın temizlenmesine (flush) ve önemli performans kayıplarına neden olduğundan, güçlü bir dal tahmin sistemi kritik öneme sahiptir \cite{smith_branch}.

Tasarlanan sistemde, dallanma komutları (B-tipi) ve doğrudan olmayan atlamalar (JALR) için ayrı tahmin mekanizmaları kullanılmaktadır. Dallanma komutları için Tournament predictor, JALR komutları için ise ayrı bir JALR predictor ve Return Address Stack (RAS) kullanılmaktadır.

\subsubsection{Tournament predictor}\label{subsubsec:tournament}

Tournament predictor, McFarling tarafından önerilen hibrit tahmin yaklaşımını temel almaktadır \cite{mcfarling}. Bu yapı, iki farklı tahmin mekanizmasını birleştirerek her birinin güçlü yönlerinden yararlanır:

\begin{itemize}
    \item \textbf{GShare predictor:} Global dal geçmişini kullanarak dallar arasındaki korelasyonları yakalar.
    \item \textbf{Bimodal predictor:} Yerel dal davranışını takip ederek güçlü bir şekilde tek yönlü dallarda yüksek doğruluk sağlar.
    \item \textbf{Chooser (Seçici):} Her dal için hangi tahmincinin daha başarılı olduğunu takip eder ve dinamik olarak seçim yapar.
\end{itemize}

Seçici tablo, 2-bit doyurma sayaçlarından oluşmaktadır. Sayaç değeri 2 veya 3 ise GShare tahmini, 0 veya 1 ise Bimodal tahmini tercih edilir:

\begin{equation}\label{eq:chooser}
prediction = \begin{cases}
gshare\_pred & \text{eğer } chooser[pc] \geq 2 \\
bimodal\_pred & \text{aksi halde}
\end{cases}
\end{equation}

\subsubsection{GShare predictor}\label{subsubsec:gshare}

GShare predictor, global dal geçmişi kaydını (GHR) dal adresi ile XOR işlemine tabi tutarak indeks oluşturur \cite{yeh_patt}. Bu yaklaşım, farklı dallar arasındaki korelasyonları yakalamada etkilidir.

\begin{equation}\label{eq:gshare_index}
index = PC[n+1:2] \oplus GHR[n-1:0]
\end{equation}

Denklem \ref{eq:gshare_index}'da, \texttt{n} indeks genişliğini temsil eder. Tasarlanan sistemde, \texttt{ENTRIES} parametresi ile yapılandırılabilir bir tablo boyutu desteklenmektedir (varsayılan 32 giriş).

GHR, her dal çözümlemesinden sonra güncellenir. Spekülatif yürütme sırasında, GHR değeri tahmin anında kaydedilir ve yanlış tahmin durumunda geri yüklenir.

\subsubsection{Bimodal predictor}\label{subsubsec:bimodal}

Bimodal predictor, en basit dinamik dal tahmin yöntemidir ve Smith tarafından önerilmiştir \cite{smith_branch}. Her dal adresi için 2-bit doyurma sayacı tutulur:

\begin{itemize}
    \item \textbf{00 (Strongly Not Taken):} Güçlü bir şekilde alınmayacak
    \item \textbf{01 (Weakly Not Taken):} Zayıf bir şekilde alınmayacak
    \item \textbf{10 (Weakly Taken):} Zayıf bir şekilde alınacak
    \item \textbf{11 (Strongly Taken):} Güçlü bir şekilde alınacak
\end{itemize}

Tahmin, sayacın en anlamlı bitine (MSB) göre yapılır. MSB 1 ise dalın alınacağı, 0 ise alınmayacağı tahmin edilir.

\subsubsection{JALR predictor ve Return Address Stack}\label{subsubsec:jalr}

Doğrudan olmayan atlamalar (JALR komutları) için ayrı bir tahmin mekanizması gerekmektedir çünkü hedef adres, bir yazmaçtan okunmakta ve derleme zamanında bilinmemektedir.

JALR predictor, iki ana bileşenden oluşmaktadır:

\begin{enumerate}
    \item \textbf{Branch Target Buffer (BTB):} Son kullanılan JALR hedef adreslerini kaydeden bir önbellek yapısıdır.
    \item \textbf{Return Address Stack (RAS):} Fonksiyon dönüşlerini (return) tahmin etmek için LIFO yapısında bir yığındır.
\end{enumerate}

RAS, fonksiyon çağrılarında (CALL) dönüş adresini yığına iter (push) ve dönüşlerde (RET) yığından çeker (pop). RISC-V'de CALL ve RET, hedef/kaynak olarak \texttt{x1} veya \texttt{x5} yazmaçlarını kullanan JAL/JALR komutları ile gerçekleştirilir.

Tasarlanan sistemde RAS derinliği 8 giriş olarak yapılandırılmıştır. Spekülatif yürütme desteklemek için, her dal tahmini sırasında RAS TOS (Top of Stack) işaretçisi kaydedilir ve yanlış tahmin durumunda geri yüklenir.

%------------------------------------------------------------------------

\subsection{Komut Arabelleği}\label{subsec:instr_buffer}

Komut arabelleği (\texttt{instruction\_buffer\_new}), Fetch ve Decode aşamaları arasında ayrıştırma (decoupling) sağlayan bir FIFO yapısıdır. Bu ayrıştırma, her iki aşamanın farklı hızlarda çalışmasına olanak tanır ve pipeline verimliliğini artırır.

\subsubsection{Dairesel tampon yapısı}\label{subsubsec:circ_buffer}

Komut arabelleği, baş (head) ve kuyruk (tail) işaretçileri ile yönetilen dairesel bir tampon olarak gerçeklenmiştir. Varsayılan tampon derinliği 16 giriştir ve 2'nin kuvveti olması zorunludur.

Her tampon girişi aşağıdaki bilgileri içermektedir:

\begin{itemize}
    \item 32-bit komut verisi
    \item 32-bit PC değeri
    \item 32-bit acil değer (hesaplanmış)
    \item Dal tahmin biti
    \item Tahmin anındaki PC değeri
    \item Global geçmiş kaydı (GHR snapshot)
    \item RAS TOS checkpoint
\end{itemize}

Tampon doluluk durumu, aşağıdaki formülle hesaplanır:

\begin{equation}\label{eq:occupancy}
occupancy = (tail - head) \mod BUFFER\_DEPTH
\end{equation}

\subsubsection{Geriye baskı mekanizması}\label{subsubsec:backpressure}

Geriye baskı (backpressure) mekanizması, tamponun dolması durumunda Fetch aşamasını yavaşlatarak veri kaybını önler. \texttt{fetch\_ready\_o} sinyali, tamponda yeterli alan olduğunda aktif hale gelir:

\begin{equation}\label{eq:fetch_ready}
fetch\_ready = \lnot flush \land \lnot buffer\_full \land (space\_available \geq 5)
\end{equation}

Beş slot gereksinimi, tek çevrimde gelebilecek maksimum komut sayısını karşılamak için belirlenmiştir.

\subsubsection{TMR korumalı işaretçiler}\label{subsubsec:tmr_buffer}

Komut arabelleği, kritik işaretçiler için Triple Modular Redundancy (TMR) koruması uygulamaktadır. Baş, kuyruk ve doluluk sayacı işaretçileri çoğaltarak korunmaktadır:

\begin{itemize}
    \item \texttt{head\_ptr\_0}, \texttt{head\_ptr\_1}, \texttt{head\_ptr\_2}: Üç kopya baş işaretçisi
    \item \texttt{tail\_ptr\_0}, \texttt{tail\_ptr\_1}, \texttt{tail\_ptr\_2}: Üç kopya kuyruk işaretçisi
    \item \texttt{count\_0}, \texttt{count\_1}, \texttt{count\_2}: Üç kopya doluluk sayacı
\end{itemize}

Her işaretçi grubu için ayrı bir \texttt{tmr\_voter} modülü kullanılmaktadır. Oylama mantığı, çoğunluk kararı ile doğru değeri belirler ve tek bit hatalarını tolere eder. Güvenli mod (\texttt{secure\_mode}) aktif değilken, TMR oylaması devre dışı bırakılır ve sadece birinci kopya kullanılır.
