\phantomsection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{BACKGROUND AND LITERATURE}\label{ch:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter presents the fundamental concepts that form the basis of this thesis work and the related literature review. First, the RISC-V instruction set architecture is introduced, followed by an explanation of the fundamental concepts of superscalar processor design. The chapter continues with fault tolerance methods and finally examines related works.

%------------------------------------------------------------------------
\section{RISC-V Architecture}\label{sec:riscv}
%------------------------------------------------------------------------

RISC-V is an open-source instruction set architecture developed at the University of California, Berkeley in 2010 \cite{riscv_spec}. Unlike traditional commercial architectures, RISC-V does not require royalty fees and offers designers complete customization freedom. These features have led to widespread adoption in research and educational applications as well as industrial applications.

\subsection{Modular Structure}\label{subsec:riscv_modular}

The fundamental design philosophy of RISC-V is modularity. The architecture consists of a mandatory base instruction set and optional extensions. The base instruction set, called RV32I, supports 32-bit integer operations.

The base instruction set uses six different instruction formats: R-type (register-register operations), I-type (immediate value operations), S-type (store), B-type (branch), U-type (upper immediate), and J-type (jump). This regular format structure allows simplification of instruction decoding hardware \cite{patterson_hennessy}.

The RISC-V architecture defines three privilege levels: machine mode (M-mode), supervisor mode (S-mode), and user mode (U-mode) \cite{riscv_priv}. While only machine mode is typically used in embedded systems, all levels can be active in systems running an operating system. The processor designed in this thesis work supports only machine mode.

%------------------------------------------------------------------------
\section{Processor Microarchitecture Concepts}\label{sec:microarchitecture}
%------------------------------------------------------------------------

Modern processors increase performance by exploiting Instruction Level Parallelism (ILP). This section explains the fundamental concepts of superscalar and out-of-order execution processors.

\subsection{Pipeline and Hazards}\label{subsec:pipeline_hazards}

Pipelined processors can start a new instruction every clock cycle by dividing the instruction execution process into independent stages. The classic five-stage pipeline consists of instruction fetch (Fetch), decode (Decode), execute (Execute), memory access (Memory), and writeback (Writeback) stages \cite{patterson_hennessy}.

Three fundamental hazard types exist in pipeline design. Data hazards occur when an instruction depends on a result that has not yet been computed. Control hazards arise from the need to determine program flow before the outcome of branch instructions is known. Structural hazards occur when multiple instructions want to access the same hardware resource simultaneously.

Forwarding and stalling techniques are used to resolve data hazards. Branch prediction mechanisms have been developed to reduce the impact of control hazards \cite{smith_branch}. Two-bit saturating counter-based prediction is widely used as a simple and effective method.

\subsection{Superscalar Execution}\label{subsec:superscalar}

Superscalar processors have the capacity to fetch, decode, and execute multiple instructions per clock cycle. An N-way superscalar processor can theoretically complete N instructions per cycle. However, actual performance falls below this theoretical maximum due to data dependencies and resource conflicts \cite{shen_lipasti}.

The effectiveness of superscalar execution depends on the instruction-level parallelism in the program. The ILP value in typical programs ranges between 2 and 5. Speculative execution and dynamic scheduling techniques are required to achieve higher parallelism.

\subsection{Out-of-Order Execution}\label{subsec:ooo}

Out-of-order execution enables instructions to be executed as soon as their operands are ready, independent of program order. This approach increases ILP utilization by reducing stalls caused by data dependencies.

The Tomasulo algorithm is the dynamic scheduling method that forms the basis of out-of-order execution \cite{tomasulo}. The algorithm implements operand waiting and result broadcasting mechanisms through reservation stations.

Register renaming plays a critical role in out-of-order execution. This technique eliminates false dependencies (WAW and WAR) that do not exist at the software level. Architectural registers are dynamically mapped to a larger physical register pool. The Register Alias Table (RAT) manages this mapping.

The Reorder Buffer (ROB) ensures that out-of-order executed instructions are committed in program order. This structure is necessary for correct handling of interrupts and exceptions. Management of speculative execution is also performed through the ROB.

\subsection{Branch Prediction and Recovery}\label{subsec:branch_prediction}

Speculative execution enables instruction fetching and execution to continue before branch outcomes are determined. The branch predictor predicts the branch decision and target address in advance. If the prediction is correct, a performance gain is achieved; if incorrect, speculative instructions are cancelled.

Two fundamental approaches exist for restoring processor state in case of misprediction. In the lazy recovery method, the mispredicted branch is waited until it reaches the ROB head, and the state is corrected by scanning backward. This approach causes high latency.

In the eager recovery method, snapshots of the RAT state are saved while branch instructions are being processed. When a misprediction is detected, the state is immediately restored from the relevant snapshot. This approach requires additional hardware called RAT Checkpoint or Shadow RAT but significantly reduces recovery latency \cite{shen_lipasti}.

%------------------------------------------------------------------------
\section{Fault Tolerance Concepts}\label{sec:fault_tolerance}
%------------------------------------------------------------------------

Miniaturization in semiconductor technology has increased the susceptibility of circuits to environmental factors. This section explains fault types and protection methods developed against them.

\subsection{Fault Types}\label{subsec:fault_types}

Hardware faults are classified into two main categories according to their permanence. Permanent faults arise from manufacturing defects or aging and persist even if the system is restarted. Transient faults generally originate from environmental factors and correct themselves \cite{baumann}.

Cosmic rays and high-energy particles can interact with semiconductor materials, causing bit-flips known as Single Event Upsets (SEU). As technology scales, the probability of a single particle affecting multiple cells increases, and Multiple Bit Upsets (MBU) occur \cite{rogenmoser_hmr_2023, annink}.

In radiation tests conducted by Santos et al., it was observed that seventy-eight percent of faults occurred in memories and fifteen percent in register files \cite{santos_2023}. These results clearly indicate that large memory structures and register files need to be protected.

\subsection{Spatial Redundancy}\label{subsec:spatial_redundancy}

Spatial redundancy involves operating multiple copies of hardware in parallel. Double Modular Redundancy (DMR) provides fault detection by comparing the results of two copies. Triple Modular Redundancy (TMR) can both detect and mask faults through majority voting of three copies \cite{lyons_tmr}.

The lock-step method applied at the core level operates multiple processor cores synchronously. DCLS (Dual Core Lock-Step) provides fault detection, while TCLS (Triple Core Lock-Step) provides fault masking. However, these approaches allow faults to propagate to the core output and increase recovery latency.

Spatial redundancy applied at the pipeline level enables faults to be detected at the stage where they occur. DuckCore, developed by Li et al., is an example of this approach \cite{li_duckcore}. Intra-core protection prevents fault propagation, offering faster recovery \cite{dorflinger_2022}.

\subsection{Temporal Redundancy}\label{subsec:temporal_redundancy}

Temporal redundancy involves repeating the same operation at different times and comparing results. This approach does not require additional hardware but reduces performance. Tedeschi et al. developed a design that provides low-cost fault tolerance using temporal redundancy \cite{tedeschi_2025}. This method can be preferred when there are power and area constraints in embedded systems.

\subsection{Information Redundancy}\label{subsec:information_redundancy}

Information redundancy provides fault detection and correction by adding additional bits to data. Error Correcting Codes (ECC) can correct single-bit errors and detect double-bit errors \cite{hamming}.

According to the work by Annink et al., ECC implementation can increase memory area by thirty-three and a half percent and power consumption by fourteen percent. However, with optimization techniques, this increase can be reduced to three percent \cite{annink}.

\subsection{On-Demand Redundancy}\label{subsec:odmr}

A significant disadvantage of traditional redundancy methods is the requirement for the system to continuously operate in redundant mode. This situation causes resource waste even during periods when fault risk is low.

On-Demand Modular Redundancy (ODMR) is a flexible approach proposed by Rogenmoser et al. \cite{rogenmoser_odrg_2022}. In ODMR, the system can switch between redundant mode and independent operation mode according to task criticality. Fault protection is provided during critical tasks, while full performance is achieved under normal conditions.

The Trikarenos project presents a concrete implementation of the ODMR approach \cite{trikarenos_2023}. This design, implemented in 28nm technology, provides flexible fault tolerance for CubeSats.

%------------------------------------------------------------------------
\section{Related Work}\label{sec:related_work}
%------------------------------------------------------------------------

This section examines superscalar RISC-V processor designs and fault-tolerant processor works.

\subsection{Superscalar RISC-V Processors}\label{subsec:superscalar_designs}

Berkeley Out-of-Order Machine (BOOM) is the most recognized open-source superscalar RISC-V processor \cite{boom}. The third-generation design, known as SonicBOOM, demonstrated 6.2 CoreMark performance per cycle \cite{sonicboom}.

The Xiangshan project is a high-performance RISC-V processor developed by the Chinese Academy of Sciences \cite{xiangshan_2022}. This design, with six-way superscalar and out-of-order execution capabilities, targets industrial-level performance.

\subsection{Fault-Tolerant RISC-V Processors}\label{subsec:ft_processors}

DuckCore, developed by Li et al., is among the first RISC-V designs providing pipeline-level fault protection \cite{li_duckcore}. The design applies TMR for register files and critical control signals.

Dörflinger et al. proposed a comprehensive fault tolerance framework for RISC-V \cite{dorflinger_2022}. This framework allows different protection levels to be applied modularly.

Rogenmoser's Trikarenos project optimized the ODMR approach for small satellite applications \cite{trikarenos_2023}. It provides flexible redundancy using three CV32E40P cores.

The approach developed by Mach and Kohútka proposes the pipeline splitting technique as an alternative to the traditional lock-step method \cite{mach_lockstep_2025}. This approach provides fault tolerance with only eight percent area overhead and saves resources by excluding large structures such as the branch predictor from protection. Faults in predictors are naturally corrected by the existing misprediction recovery mechanism.

\subsection{Thesis Positioning}\label{subsec:thesis_positioning}

When existing works are examined, fault-tolerant superscalar out-of-order execution RISC-V processor designs are not directly encountered. Works such as DuckCore provide pipeline-level protection but do not support out-of-order execution. High-performance designs such as BOOM do not include fault tolerance.

This thesis presents a novel RISC-V processor design that combines superscalar out-of-order execution capacity with intra-core TMR protection using the ODMR method. Thanks to the ODMR approach, a dynamic balance between performance and reliability can be established.
