%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 3.2 KOMBİNASYONU GETİRME (FETCH) AŞAMASI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Komut Getirme Aşaması}\label{sec:fetch}

Komut getirme aşaması, süperölçekli işlemcinin boruhattındaki ilk aşamadır ve program akışını belirleyen kritik bir rol üstlenmektedir. Bu aşama, bellekten komutların paralel olarak getirilmesi, dal davranışlarının önceden tahmin edilmesi ve getirilen komutların sonraki aşamalar için tamponlanması görevlerini yerine getirmektedir. Tasarlanan işlemcide komut getirme aşaması üç temel bileşenden oluşmaktadır: çoklu getirme birimi, dal tahmin sistemi ve komut tamponu.

\subsection{Çoklu Getirme Birimi}\label{subsec:multi_fetch}

Çoklu getirme birimi, süperölçekli işlemcinin komut seviyesi paralelliğinden yararlanabilmesi için tasarlanmış merkezi koordinasyon birimidir. Bu modül, her saat çevriminde bellekten beş komut getirme kapasitesine sahiptir ve getirilen komutların geçerliliğini dal tahmin sonuçlarına göre dinamik olarak belirlemektedir.

\begin{figure}[htbp]
    \centering
    \fbox{\textbf{[GÖRSEL: Çoklu Getirme Birimi Şeması - 5-genişlikli fetch mantığı, PC, PC+4..PC+16 Artırma, Instruction Memory Bağlantısı]}}
    \caption{Çoklu getirme birimi ve paralel komut erişimi yapısı}
    \label{fig:multi_fetch_unit}
\end{figure}

\subsubsection{Beş Genişlikli Getirme Tasarımının Gerekçesi}

Tasarlanan işlemci üç yollu bir komut verme yapısına sahip olmasına rağmen, komut getirme genişliği beş olarak belirlenmiştir. Bu asimetrik tasarım kararının arkasında önemli bir gerekçe bulunmaktadır.

İşlemcinin tüm bileşenleri, çevrim başına komut sayısını teorik sınır olan üçe yaklaştırmaya çalışmaktadır. Bu hedef doğrultusunda, komut getirme aşamasının da her saat çevriminde ortalama üç komutu boruhattının ileri bölümlerine beslemesi gerekmektedir. Ancak ``alınacak'' olarak tahmin edilen dallanma komutları ile doğrudan ve dolaylı atlama komutları nedeniyle, getirilen her komut boruhattının ileri kısımlarına iletilemeyebilmektedir. Bu durumda, tahmin edilen dallanma veya atlama komutunun ardından gelen komutlar geçersiz sayılmakta ve komut tamponuna yazılmamaktadır.

Bu kayıpları telafi etmenin yolu, sonraki çevrimlerde üçten fazla komut getirmektir. Beş genişlikli getirme tasarımı sayesinde, dallanma ve atlama komutları nedeniyle bazı komutlar geçersiz olsa bile, komut tamponuna yazılan ortalama komut sayısının üç olması hedeflenmektedir. Bu yaklaşım, komut getirme aşamasının boruhattı için bir darboğaz oluşturmasını engellemektedir.

\subsubsection{Paralel Komut Getirme Mekanizması}

Paralel komut getirme mekanizması, ardışık beş bellek adresine eş zamanlı erişim sağlayarak yüksek verim elde edilmesini mümkün kılmaktadır. Her bir komut için ayrı adres çıkışları ve komut girişleri bulunmaktadır. Komut adresleri program sayacı değerinden başlayarak dörder bayt aralıklarla hesaplanmaktadır; bu durum RISC-V mimarisindeki 32 bitlik sabit komut uzunluğundan kaynaklanmaktadır.

Getirilen komutların geçerliliği, dal tahmin sonuçlarına bağlı olarak belirlenmektedir. Herhangi bir komut için dallanma veya atlama tahmini ``alınacak'' sonucunu verdiğinde, bu komutun ardından gelen tüm komutlar otomatik olarak geçersiz işaretlenmektedir. Bu komutların sonraki aşamalara iletilmemesinin nedeni, bu komutların işlenmemesi gerektiğinin tahmin edilmesidir; eğer bu komutlar sonraki aşamalara iletilseydi, işlemci yanlış program akışını izleyerek hatalı çalışırdı.

% TODO: Buraya görsel eklenecek - 5 komuttan 2. komut taken branch olacak, sonrakilerin geçersiz olduğunu gösterecek
\begin{figure}[htbp]
\centering
\fbox{\textbf{[GÖRSEL PLACEHOLDER: 5 komuttan 2. komut taken branch, sonrakiler geçersiz]}}
\caption{Dallanma komutu nedeniyle sonraki komutların geçersizleşmesi}
\label{fig:fetch_invalidation}
\end{figure}

Geçersizleme mantığı kademeli olarak çalışmaktadır: birinci komut dallanır veya atlarsa ikinci, üçüncü, dördüncü ve beşinci komutlar geçersiz olmakta; ikinci komut dallanır veya atlarsa üçüncü, dördüncü ve beşinci komutlar geçersiz olmakta ve bu mantık beşinci komuta kadar devam etmektedir.

\subsubsection{Erken Aşama Sabit Değer Çözümleyicisi}

Dal hedef adreslerinin erken hesaplanabilmesi için her komuta bir erken aşama sabit değer çözümleyici modülü eklenmiştir. Bu modüller, tam komut çözümleme işlemi beklenmeden komut içindeki sabit değerleri çıkarmaktadır. RISC-V komut formatlarının düzenli yapısı, bu erken çözümleme işlemini kolaylaştırmaktadır.

Dal komutlarının hedef adresi, mevcut program sayacı değeri ile komut içindeki sabit değerin toplanmasıyla hesaplanmaktadır.

\begin{equation}
    Hedef\_Adres = PC + Ofset
    \label{eq:branch_target}
\end{equation}

Bu hesaplamanın komut getirme aşamasında gerçekleştirilmesi, dal tahmininin doğru hedef adresini tek saat çevriminde belirlemesine olanak tanımaktadır. Sabit değer çözümleyici, B tipi dallanma komutları ve J tipi atlama komutları için farklı bit alanlarından değer çıkarmakta ve işaret genişletmesi uygulamaktadır.

\subsubsection{Yanlış Tahmin İşleme}

Bir dal veya atlama komutu yanlış tahmin edildiğinde, boruhattındaki tüm spekülatif durumun temizlenmesi ve doğru program akışına dönülmesi gerekmektedir. Tasarlanan işlemcide aynı anda üç komut işlenebildiğinden, aynı çevrimde birden fazla yanlış tahmin sonucu oluşabilmektedir. Bu sonuçlar sıra dışı hesaplanmış olsa bile, hızlıca sıraya konularak temizleme işlemine başlanmaktadır.

Gelebilecek olan üç yanlış tahminden en eski olanı dikkate alınmalıdır. Bunun nedeni, daha genç dalların eski dalın spekülatif yolunda bulunabilmesidir. Eski yanlış tahmin düzeltildiğinde, genç dallar zaten temizlenecektir; dolayısıyla genç yanlış tahminleri ayrıca işlemek gereksiz hesaplama yapmak anlamına gelmektedir. Bu önceliklendirme, çoklu getirme birimindeki yanlış tahmin işleme mantığı tarafından gerçekleştirilmektedir: sıfırıncı kanaldan gelen yanlış tahmin birinci ve ikinci kanallara göre önceliklidir, birinci kanaldan gelen yanlış tahmin ise ikinci kanala göre önceliklidir.

Temizleme sinyali etkinleştirildiğinde, program sayacı doğru hedef adresine yönlendirilmekte ve komut tamponu boşaltılmaktadır.

%------------------------------------------------------------------------

\subsection{Program Sayacı Denetleyicisi}\label{subsec:pc_ctrl}

Program sayacı denetleyicisi, bir sonraki getirme adresini belirlemekten sorumlu olan kritik bir bileşendir. Bu birim, çeşitli kaynaklardan gelen bilgileri değerlendirerek program sayacı değerinin nasıl güncelleneceğine karar vermektedir.

\subsubsection{Program Sayacı Güncelleme Senaryoları}

Program sayacı güncellemesi, dört farklı senaryoya göre gerçekleşmektedir ve bu senaryolar belirli bir öncelik sırasına göre değerlendirilmektedir.

En yüksek öncelikli senaryo, yanlış tahmin düzeltmesidir. Yürütme aşamasından bir yanlış tahmin sinyali geldiğinde, program sayacı dal kayıt tablosundan alınan doğru adrese yönlendirilmektedir. Bu durum, tüm diğer güncellemeleri geçersiz kılmaktadır çünkü doğru program akışının yeniden kurulması en kritik önceliğe sahiptir.

İkinci öncelikli senaryo, dolaylı atlama tahminlerini içermektedir. JALR komutu için bir tahmin mevcut olduğunda, program sayacı bu tahmin edilen hedef adrese güncellenmektedir.

Üçüncü öncelikli senaryo, doğrudan dallanma ve atlama komutlarını kapsamaktadır. Dallanma veya JAL komutu ``alınacak'' olarak tahmin edildiğinde, program sayacı mevcut değere sabit değerin eklenmesiyle hesaplanan hedef adrese güncellenmektedir.

Dördüncü ve son senaryo, normal ardışık ilerlemedir. Hiçbir dallanma veya atlama komutu tahmin edilmediğinde, program sayacı beş komut için yirmi bayt ileri taşınmaktadır.

\subsubsection{Paralel Program Sayacı Hesaplaması}

Beş komut için program sayacı değerleri paralel olarak hesaplanmaktadır. Her komut için mevcut program sayacı değeri ile dört, sekiz, on iki ve on altı baytlık sabit ofsetler toplanarak ardışık adresler elde edilmektedir. Bu paralel hesaplama, komut getirme işleminin gecikmesini en aza indirmektedir.

Ayrıca, atlama komutları için dönüş adresi değerleri de hesaplanmaktadır. JAL ve JALR komutları, bağlantı yazmacına mevcut komutun bir sonraki adresini kaydetmektedir. Bu değer, program sayacının dört bayt ötesine karşılık gelmektedir.

%------------------------------------------------------------------------

\subsection{Dal Tahmin Sistemi}\label{subsec:branch_pred}

Dal tahmin sistemi, kontrol akışı değişikliklerinin erken tespit edilmesini ve yüksek doğrulukla öngörülmesini sağlamaktadır. Tipik programlarda dallanma ve atlama komutları yüzde on beş ile yüzde yirmi beş arasında bir orana sahiptir \cite{patterson_hennessy}. Etkili bir dal tahmini olmadan, her dal komutu boruhattında birkaç saat çevrimi gecikmeye neden olmaktadır; bu durum işlemci performansını önemli ölçüde düşürmektedir.

Yanlış tahmin cezasının süperölçekli işlemcilere etkisi, skaler işlemcilere kıyasla çok daha yıkıcıdır. Bunun temel nedeni, geniş boruhattında daha fazla spekülatif komutun aynı anda işleniyor olması ve bir yanlış tahmin durumunda tüm bu komutların boşa gitmesidir. Etkin çevrim başına komut değeri ($IPC_{etkin}$), ideal değer ($W$), dallanma oranı ($B$), yanlış tahmin oranı ($M$) ve ceza çevrimi ($P$) cinsinden şu şekilde ifade edilmektedir:

\begin{equation}
    IPC_{etkin} = \frac{W}{1 + W \cdot B \cdot M \cdot P}
    \label{eq:ipc_mispred}
\end{equation}

Bu denklemde $W$ işlemci genişliğini (skaler için 1, üç yollu süperölçekli için 3), $B$ dallanma komut oranını, $M = (1 - Doğruluk)$ yanlış tahmin oranını ve $P$ yanlış tahmin cezası çevrim sayısını ifade etmektedir. Yüzde yirmi dallanma oranı ($B = 0.20$), yüzde seksen tahmin doğruluğu ($M = 0.20$) ve üç çevrimlik ceza ($P = 3$) varsayımlarıyla:

\begin{align}
    IPC_{skaler} &= \frac{1}{1 + 1 \times 0.20 \times 0.20 \times 3} = \frac{1}{1.12} = 0.89 \label{eq:ipc_scalar} \\
    IPC_{super}  &= \frac{3}{1 + 3 \times 0.20 \times 0.20 \times 3} = \frac{3}{1.36} = 2.21 \label{eq:ipc_super}
\end{align}

Verimlilik açısından değerlendirildiğinde, skaler işlemci ideal değerinin yüzde seksen dokuzunu korurken ($\eta_{skaler} = 0.89/1 = \%89$), süperölçekli işlemci yalnızca yüzde yetmiş dördünü koruyabilmektedir ($\eta_{super} = 2.21/3 = \%74$). Bu analiz, süperölçekli mimarilerde dal tahmini doğruluğunun neden kritik öneme sahip olduğunu açıkça ortaya koymaktadır.

Tasarlanan sistemde iki ana tahmin mekanizması bulunmaktadır: koşullu dallanma komutları için iki bitlik sayaç tahmincisi ve dolaylı atlama komutları için JALR tahmincisi.

\subsubsection{Dal Tahmincisi Tasarım Kararları}

Tasarım sürecinde, GShare tabanlı turnuva tahmincisi geliştirilmiş ve test edilmiştir. Bu tahminci, iki bitlik sayaç ve GShare tahminlerini birleştirerek her dalın davranışına uygun tahminci seçimi yapmaktadır. Yapılan testlerde, turnuva tahmincisinin doğruluk oranında önemli bir artış sağladığı gözlemlenmiştir.

Ancak turnuva tahmincisinin pratik uygulamasında iki kritik kısıtlama ile karşılaşılmıştır:

\textbf{Bellek Gereksinimi ve Sentez Kısıtlamaları:} GShare tahmincisi, program sayacı ile küresel dal geçmişinin XOR işlemiyle indekslenmektedir. Bu yaklaşımda ``takma ad'' (aliasing) problemi kritik bir faktördür; birbirleriyle ilişkisiz dallar aynı tablo girişini paylaşarak birbirlerinin eğitimini bozabilmektedir \cite{mcfarling}. Araştırmalar, GShare tahmincisinin kabul edilebilir doğruluk için en az 4096 girişlik tabloya ihtiyaç duyduğunu göstermektedir \cite{yeh_patt}.

Bu boyutta bir tablo, tipik olarak SRAM hücreleri olarak sentezlenmektedir. Ancak kullanılan geliştirme ortamında, otomatik bellek çıkarımı (memory inference) yapabilen bir sentez aracına erişim bulunmamaktaydı. Tabloların salt flip-flop olarak sentezlenmesi, kabul edilemeyecek düzeyde alan tüketimine neden olmaktadır.

\textbf{Gecikme ve Yanlış Tahmin Cezası Endişesi:} Büyük tablolara erişim, tek saat çevriminde tamamlanamayabilir. Bu durumda, komut getirme aşamasının boruhattına bölünmesi (pipelining) gerekmektedir. Boruhattı eklenmesi, tahmin sonucunun gecikmesine neden olmakta ve \textbf{yanlış tahmin cezasını artırmaktadır}.

\subsubsection{Doğruluk ve Yanlış Tahmin Cezası Dengeleme Analizi}

Yanlış tahmin cezasının artması, doğruluk artışının sağlayacağı faydayı ortadan kaldırabilir. Bu dengeyi analiz etmek için IPC formülünü farklı senaryolara uygulayalım.

\textbf{Senaryo 1 - Basit Tahminci (256 giriş):}
\begin{itemize}
    \item Tahmin doğruluğu: \%80 (yanlış tahmin oranı $M_1 = 0.20$)
    \item Yanlış tahmin cezası: 3 çevrim ($P_1 = 3$)
\end{itemize}

\textbf{Senaryo 2 - Gelişmiş Tahminci (4096 giriş, boruhattılı):}
\begin{itemize}
    \item Tahmin doğruluğu: \%85 (yanlış tahmin oranı $M_2 = 0.15$, \%5 iyileşme)
    \item Yanlış tahmin cezası: 4 çevrim ($P_2 = 4$, boruhattı nedeniyle 1 çevrim artış)
\end{itemize}

Dallanma oranı $B = 0.20$ ve işlemci genişliği $W = 3$ varsayımlarıyla IPC değerlerini hesaplayalım:

\begin{align}
    IPC_1 &= \frac{3}{1 + 3 \times 0.20 \times 0.20 \times 3} = \frac{3}{1.36} = 2.21 \label{eq:ipc_simple} \\
    IPC_2 &= \frac{3}{1 + 3 \times 0.20 \times 0.15 \times 4} = \frac{3}{1.36} = 2.21 \label{eq:ipc_complex}
\end{align}

İlgi çekici şekilde, her iki senaryo da \textbf{aynı IPC değerini} vermektedir. $0.20 \times 3 = 0.60$ ve $0.15 \times 4 = 0.60$ olduğundan, doğruluk artışı ve ceza artışı birbirini dengelemektedir.

Ceza artışının etkisi doğruluk artışının etkisinden büyük olabilir:

\textbf{Senaryo 3 - Yüksek Ceza Durumu:}
\begin{itemize}
    \item Tahmin doğruluğu: \%85 ($M_3 = 0.15$)
    \item Yanlış tahmin cezası: 5 çevrim ($P_3 = 5$, 2 çevrim artış)
\end{itemize}

\begin{equation}
    IPC_3 = \frac{3}{1 + 3 \times 0.20 \times 0.15 \times 5} = \frac{3}{1.45} = 2.07 \label{eq:ipc_worse}
\end{equation}

Bu senaryoda, \textbf{doğruluk artmasına rağmen IPC düşmüştür} (2.21'den 2.07'ye).

\subsubsection{Tercih Edilen Tasarım: İki Bitlik Sayaç Tahmincisi}

Yukarıdaki kısıtlamalar ve analizler ışığında, turnuva tahmincisi daha iyi tahmin doğruluğu sunmasına rağmen, \textbf{256 girişli iki bitlik sayaç tahmincisi} tercih edilmiştir. Bu tercih şu gerekçelere dayanmaktadır:

\begin{itemize}
    \item Uygun bellek sentezi aracı bulunmaması nedeniyle büyük tablolar pratik değildir.
    \item Boruhattılı tasarımın getireceği ceza artışı, doğruluk kazancını dengeleyebilir veya olumsuz etki yapabilir.
    \item Basit tahminci ile benzer IPC değerleri, çok daha küçük alan maliyetiyle elde edilebilmektedir.
\end{itemize}

İki bitlik sayaç tahmincisi, en temel dinamik dal tahmin yöntemidir. Sayaç dört durumdan birinde bulunabilmektedir: güçlü alınmayacak (00), zayıf alınmayacak (01), zayıf alınacak (10) ve güçlü alınacak (11). Sayacın en anlamlı biti, dalın tahmin edilen yönünü belirlemektedir.

İki bitlik sayaç kullanılmasının nedeni, tek bitlik sayacın tek bir yanlış sonuçta hemen tahmini değiştirmesidir. Döngü sonlarında bu durum sorunlu olmaktadır: bir döngü yüz kez ``alınacak'' olduktan sonra bir kez ``alınmayacak'' olmaktadır ve tek bitlik sayaç hemen ``alınmayacak'' tahmin etmeye başlamaktadır. İki bitlik sayaç, iki ardışık yanlış sonuç gerektirdiğinden bu tür anomali durumlarına karşı dayanıklılık sağlamaktadır \cite{smith_branch}.

256 girişlik tablo boyutu, flip-flop tabanlı sentez için kabul edilebilir bir maliyettir. Tablo indeksi, program sayacının uygun bitlerinden türetilmektedir. Tahmin ve güncelleme işlemleri tek saat çevriminde tamamlanmakta, böylece yanlış tahmin cezası minimumda tutulmaktadır.

\begin{figure}[htbp]
    \centering
    \fbox{\textbf{[GÖRSEL: İki Bitlik Sayaç Tahmincisi - Durum Makinesi ve 256 Girişli Tablo Yapısı]}}
    \caption{İki bitlik doyurma sayacı tahmincisi mimarisi}
    \label{fig:bimodal_predictor}
\end{figure}


\subsubsection{JALR Tahmincisi ve Dönüş Adresi Yığını}\label{subsubsec:jalr}

Dolaylı atlama komutları, hedef adresini bir yazmaçtan okuduğundan derleme zamanında bilinmemektedir. Bu nedenle JALR komutları için ayrı bir tahmin mekanizması gerekmektedir.

JALR tahmincisi iki temel bileşenden oluşmaktadır: JALR hedef tamponu ve dönüş adresi yığını.

\begin{figure}[htbp]
    \centering
    \fbox{\textbf{[GÖRSEL: JALR Tahmincisi ve RAS - Hedef Önbelleği (Target Cache) ve Dönüş Adresi Yığını (RAS) yapısı]}}
    \caption{Dolaylı atlama tahmincisi ve dönüş adresi yığını}
    \label{fig:jalr_ras}
\end{figure}

JALR hedef tamponu, daha önce yürütülen JALR komutlarının hedef adreslerini saklayan bir önbellek yapısıdır. Bu yapı, program sayacı değerine göre indekslenmekte ve son kullanılan hedef adresi döndürmektedir. Birçok dolaylı atlama, özellikle sanal fonksiyon çağrıları ve anahtarlama ifadeleri, aynı hedef adrese tekrar tekrar atladığından bu yaklaşım yüksek doğruluk sağlamaktadır.

Tasarlanan sistemde JALR hedef tamponu otuz iki giriş kapasitesine sahiptir. Her giriş geçerlilik biti, etiket değeri ve hedef adres içermektedir. Etiket karşılaştırması, farklı JALR komutlarını ayırt etmek için kullanılmaktadır.

Dönüş adresi yığını, fonksiyon çağrısı ve dönüş kalıplarını tahmin etmek için özelleştirilmiş bir yapıdır. Fonksiyon çağrılarının çoğunluğu çağrı ve dönüş çiftleri şeklinde gerçekleşmektedir; bu durum son giren ilk çıkar yapısıyla doğal olarak eşleşmektedir.

RISC-V mimarisinde çağrı ve dönüş komutları, hedef veya kaynak olarak x1 veya x5 yazmaçlarını kullanan JAL ve JALR komutları ile gerçekleştirilmektedir. Çağrı komutu tespit edildiğinde, dönüş adresi yığına itilmektedir; dönüş komutu tespit edildiğinde ise yığından çekilmekte ve hedef adres olarak kullanılmaktadır.

Tasarlanan sistemde dönüş adresi yığını sekiz giriş derinliğindedir. Spekülatif yürütmeyi desteklemek için, her dal tahmini sırasında yığın tepe işaretçisi dal kayıt tablosuna kaydedilmekte ve yanlış tahmin durumunda geri yüklenmektedir.

%------------------------------------------------------------------------

\subsection{Komut Tamponu}\label{subsec:instr_buffer}

Komut tamponu, komut getirme ve kod çözme aşamaları arasında ayrıştırma sağlayan bir ilk giren ilk çıkar yapısıdır. Bu ayrıştırma, her iki aşamanın farklı hızlarda çalışmasına olanak tanımakta ve boruhattı verimliliğini artırmaktadır.

\begin{figure}[htbp]
    \centering
    \fbox{\textbf{[GÖRSEL: Komut Tamponu Yapısı - Dairesel Tampon, Baş/Kuyruk İşaretçileri, Giriş Formatı (Instr, PC, Pred Info)]}}
    \caption{Komut tamponu dairesel yapısı ve giriş formatı}
    \label{fig:instr_buffer}
\end{figure}

\subsubsection{Tampon Tasarımının Gerekçesi}

Komut getirme aşaması dallanma ve atlama komutları nedeniyle, boruhattının ileri aşamaları ise veri bağımlılıkları, bellek işlemleri ve daha birçok sebeple farklı hızlarda çalışabilmektedir. Komut belleğinden komutları hızlıca alıp bunları boruhattının ileriki aşamalarının kullanabileceği şekilde bir tamponda toplamak, işlemcinin karmaşıklığını azaltmakla birlikte performansını da artırmaktadır.

Ayrıca, komut verme aşaması duraklatıldığında komut getirme aşaması tampon dolana kadar çalışmaya devam edebilmektedir. Bu yalıtım, kısa süreli duraksamaların boruhattının tamamını etkilemesini engellemektedir.

\subsubsection{Dairesel Tampon Yapısı}

Komut tamponu, baş ve kuyruk işaretçileri ile yönetilen dairesel bir tampon olarak gerçeklenmiştir. Varsayılan tampon derinliği on altı giriştir ve bu değerin ikinin kuvveti olması zorunludur; bu gereksinim modüler aritmetik işlemlerini basitleştirmektedir.

Her tampon girişi çeşitli bilgiler içermektedir: otuz iki bitlik komut verisi, otuz iki bitlik program sayacı değeri, otuz iki bitlik hesaplanmış sabit değer, dal tahmini sonucu, tahmin anındaki program sayacı değeri, küresel geçmiş kaydı ve dönüş adresi yığını tepe işaretçisi değeri. Bu bilgiler, komutun sonraki aşamalarda doğru bir şekilde işlenmesi için gereklidir.

\subsubsection{Geri Baskı Mekanizması}

Geri baskı mekanizması, tamponun dolması durumunda komut getirme aşamasını yavaşlatarak veri kaybını önlemektedir. Tamponda en az beş boş alan bulunduğunda, getirme hazır sinyali etkinleştirilmektedir. Beş alan gereksinimi, tek çevrimde gelebilecek maksimum komut sayısını karşılamak için belirlenmiştir.

Eğer beşten az yer varken de komutları tampona koymaya çalışılsaydı, bir sonraki komut adresinin hesabı daha karmaşık hale gelecekti. Mevcut yapı ile gayet iyi sonuçlar alındığından, adres hesaplama mantığını basit tutmak daha mantıklı bulunmuştur.
