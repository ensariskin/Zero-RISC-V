RISC-V Assembly Analysis for multiply.c
==========================================

C Code:
-------
#include <stdio.h>
int main() {
    printf("Starting multiply program...\n");
    int mul = 1;
    for (int i = 1; i <= 5; i++) {
        mul *= i;
        printf("Count: %d, Mul : %d\n", i, mul);
    }
    printf("Multiply program finished!\n");
    return 0;
}

RISC-V Assembly Analysis:
========================

1. FUNCTION PROLOGUE (000101b0-000101bc):
   101b0: addi sp,sp,-32      # Allocate 32 bytes on stack
   101b4: sw   ra,28(sp)      # Save return address
   101b8: sw   s0,24(sp)      # Save frame pointer
   101bc: addi s0,sp,32       # Set up frame pointer

2. FIRST PRINTF CALL (000101c0-000101c8):
   101c0: lui  a5,0x22        # Load upper immediate for string address
   101c4: addi a0,a5,-1120    # Complete string address in a0
   101c8: jal  107f0 <puts>   # Call puts function

3. VARIABLE INITIALIZATION (000101cc-000101d8):
   101cc: li   a5,1           # Load immediate 1
   101d0: sw   a5,-20(s0)     # Store mul = 1 (at s0-20)
   101d4: li   a5,1           # Load immediate 1  
   101d8: sw   a5,-24(s0)     # Store i = 1 (at s0-24)

4. JUMP TO LOOP CONDITION (000101dc):
   101dc: j    10214 <main+0x64>  # Jump to loop condition check

5. LOOP BODY - MULTIPLICATION (000101e0-000101ec):
   101e0: lw   a1,-24(s0)     # Load i into a1
   101e4: lw   a0,-20(s0)     # Load mul into a0
   101e8: jal  10244 <__mulsi3>  # Call multiplication function
   101ec: mv   a5,a0          # Move result to a5
   101f0: sw   a5,-20(s0)     # Store result back to mul

6. LOOP BODY - PRINTF CALL (000101f4-00010204):
   101f4: lw   a2,-20(s0)     # Load mul for printf (3rd arg)
   101f8: lw   a1,-24(s0)     # Load i for printf (2nd arg) 
   101fc: lui  a5,0x22        # Load format string address
   10200: addi a0,a5,-1088    # Complete format string address
   10204: jal  106d0 <printf> # Call printf

7. LOOP INCREMENT (00010208-00010210):
   10208: lw   a5,-24(s0)     # Load i
   1020c: addi a5,a5,1        # Increment i (i++)
   10210: sw   a5,-24(s0)     # Store incremented i

8. LOOP CONDITION CHECK (00010214-0001021c):
   10214: lw   a4,-24(s0)     # Load i into a4
   10218: li   a5,5           # Load constant 5 into a5
   1021c: bge  a5,a4,101e0    # Branch if 5 >= i (continue loop)

9. FINAL PRINTF AND RETURN (00010220-00010240):
   10220: lui  a5,0x22        # Load final string address
   10224: addi a0,a5,-1064    # Complete final string address
   10228: jal  107f0 <puts>   # Call puts for final message
   1022c: li   a5,0           # Load return value 0
   10230: mv   a0,a5          # Move return value to a0
   10234: lw   ra,28(sp)      # Restore return address
   10238: lw   s0,24(sp)      # Restore frame pointer
   1023c: addi sp,sp,32       # Deallocate stack space
   10240: ret                 # Return to caller

MULTIPLICATION FUNCTION (__mulsi3):
==================================
Since RV32I doesn't have hardware multiply, the compiler generates
a software multiplication routine using shift and add:

10244: mv   a2,a0          # Copy multiplicand to a2
10248: li   a0,0           # Initialize result to 0
1024c: andi a3,a1,1        # Check LSB of multiplier
10250: beqz a3,10258       # Skip add if LSB is 0
10254: add  a0,a0,a2       # Add multiplicand to result
10258: srli a1,a1,0x1      # Shift multiplier right
1025c: slli a2,a2,0x1      # Shift multiplicand left
10260: bnez a1,1024c       # Continue if multiplier != 0
10264: ret                 # Return result in a0

KEY OBSERVATIONS:
================
1. Stack usage: 32 bytes allocated for local variables and function calls
2. Variables stored on stack: mul at s0-20, i at s0-24
3. RV32I base instructions only (no multiply instruction)
4. Software multiplication using shift-and-add algorithm
5. Function calls use JAL (jump and link) instruction
6. Standard RISC-V calling convention (a0-a7 for arguments, a0 for return)
7. Proper stack frame management with prologue/epilogue

INSTRUCTION TYPES USED:
======================
- Arithmetic: addi, add, li
- Logical: andi, srli, slli
- Memory: lw, sw
- Control: jal, beqz, bnez, bge, ret, j
- Data movement: mv, lui
