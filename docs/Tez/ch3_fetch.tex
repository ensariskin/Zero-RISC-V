%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 3.2 KOMUT GETİRME (FETCH) AŞAMASI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Komut Getirme Aşaması}\label{sec:fetch}

Komut getirme aşaması, süperölçekli işlemcinin boruhattındaki ilk aşamadır ve program akışını belirleyen kritik bir rol üstlenmektedir. Bu aşama, bellekten komutların paralel olarak getirilmesi, dal davranışlarının önceden tahmin edilmesi ve getirilen komutların sonraki aşamalar için tamponlanması görevlerini yerine getirmektedir. Tasarlanan işlemcide komut getirme aşaması üç temel bileşenden oluşmaktadır: çoklu getirme birimi, dal tahmin sistemi ve komut tamponu.

\subsection{Çoklu Getirme Birimi}\label{subsec:multi_fetch}

Çoklu getirme birimi, süperölçekli işlemcinin komut seviyesi paralelliğinden yararlanabilmesi için tasarlanmış merkezi koordinasyon birimidir. Bu modül, her saat çevriminde bellekten beş komut getirme kapasitesine sahiptir ve getirilen komutların geçerliliğini dal tahmin sonuçlarına göre dinamik olarak belirlemektedir.


Tasarlanan işlemci üç yollu bir komut verme yapısına sahip olmasına rağmen, komut getirme genişliği beş olarak belirlenmiştir. Bu asimetrik tasarım kararının arkasında önemli bir gerekçe bulunmaktadır.

İşlemcinin tüm bileşenleri, çevrim başına komut sayısını teorik sınır olan üçe yaklaştırmaya çalışmaktadır. Bu hedef doğrultusunda, komut getirme aşamasının da her saat çevriminde ortalama üç komutu boruhattının ileri bölümlerine beslemesi gerekmektedir. Ancak ``alınacak'' olarak tahmin edilen dallanma komutları ile doğrudan ve dolaylı atlama komutları nedeniyle, getirilen her komut boruhattının ileri kısımlarına iletilemeyebilmektedir. Bu durumda, tahmin edilen dallanma veya atlama komutunun ardından gelen komutlar geçersiz sayılmakta ve komut tamponuna yazılmamaktadır.

Bu kayıpları telafi etmenin yolu, sonraki çevrimlerde üçten fazla komut getirmektir. Beş genişlikli getirme tasarımı sayesinde, dallanma ve atlama komutları nedeniyle bazı komutlar geçersiz olsa bile, komut tamponuna yazılan ortalama komut sayısının üç olması hedeflenmektedir. Bu yaklaşım, komut getirme aşamasının boruhattı için bir darboğaz oluşturmasını engellemektedir.



Paralel komut getirme mekanizması, ardışık beş bellek adresine eş zamanlı erişim sağlayarak yüksek verim elde edilmesini mümkün kılmaktadır. Her bir komut için ayrı adres çıkışları ve komut girişleri bulunmaktadır. Komut adresleri program sayacı değerinden başlayarak dörder bayt aralıklarla hesaplanmaktadır; bu durum RISC-V mimarisindeki 32 bitlik sabit komut uzunluğundan kaynaklanmaktadır.

Getirilen komutların geçerliliği, dal tahmin sonuçlarına bağlı olarak belirlenmektedir. Herhangi bir komut için dallanma veya atlama tahmini ``alınacak'' sonucunu verdiğinde, bu komutun ardından gelen tüm komutlar otomatik olarak geçersiz işaretlenmektedir. Bu komutların sonraki aşamalara iletilmemesinin nedeni, bu komutların işlenmemesi gerektiğinin tahmin edilmesidir; eğer bu komutlar sonraki aşamalara iletilseydi, işlemci yanlış program akışını izleyerek hatalı çalışırdı.

Geçersizleme mantığı kademeli olarak çalışmaktadır: birinci komut dallanır veya atlarsa ikinci, üçüncü, dördüncü ve beşinci komutlar geçersiz olmakta; ikinci komut dallanır veya atlarsa üçüncü, dördüncü ve beşinci komutlar geçersiz olmakta ve bu mantık beşinci komuta kadar devam etmektedir. Bu durum Şekil \ref{fig:fetch_invalidation}'de gösterilmektedir.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=0cm,
    % Tüm kutular için sabit stil. 'text depth' ve 'text height' ekleyerek
    % içerik ne olursa olsun satır hizasını zorluyoruz.
    common/.style={draw, rectangle, minimum width=2cm, minimum height=1.2cm, align=center},
    instr/.style={common, fill=white},
    invalid/.style={common, fill=gray!30, pattern=north east lines, pattern color=gray},
    branch/.style={common, fill=green!20} % Yeşil renk, standart boyut
]

% Komut Kutuları
\node[instr] (i0) {Instr 0\\(ALU)};
\node[instr, right=of i0] (i1) {Instr 1\\(ALU)};

% BURASI DEĞİŞTİ: İçerik 2 satıra düşürüldü, "TAKEN" silindi.
\node[branch, right=of i1] (i2) {\textbf{Instr 2}\\\textbf{(Branch)}};

\node[invalid, right=of i2] (i3) {Instr 3\\(Geçersiz)};
\node[invalid, right=of i3] (i4) {Instr 4\\(Geçersiz)};

% Açıklamalar (PC değerleri)
\node[above=0.2cm of i0] {PC};
\node[above=0.2cm of i1] {PC+4};
\node[above=0.2cm of i2] {PC+8};
\node[above=0.2cm of i3] {PC+12};
\node[above=0.2cm of i4] {PC+16};

% Branch Oku (Kırmızı atlama oku)
% "Taken" bilgisini buraya taşıdık
\draw[->, very thick, red] (i2.south) -- ++(0,-0.6) -- ++(4,0) node[midway, above] {\textit{Taken} / Hedefe Atla} -- ++(0,-0.5);

% Geçersizlik Çarpıları
\draw[red, thick] (i3.south west) -- (i3.north east);
\draw[red, thick] (i3.north west) -- (i3.south east);
\draw[red, thick] (i4.south west) -- (i4.north east);
\draw[red, thick] (i4.north west) -- (i4.south east);

\end{tikzpicture}
\caption{Dallanma komutu (Instr 2) ''Alınacak'' olarak tahmin edildiğinde, paket içindeki sonraki komutların (Instr 3, 4) geçersiz kılınması.}
\label{fig:fetch_invalidation}
\end{figure}



Dal hedef adreslerinin erken hesaplanabilmesi için her komuta bir erken aşama sabit değer çözümleyici modülü eklenmiştir. Bu modüller, tam komut çözümleme işlemi beklenmeden komut içindeki sabit değerleri çıkarmaktadır. RISC-V komut formatlarının düzenli yapısı, bu erken çözümleme işlemini kolaylaştırmaktadır.

Dal komutlarının hedef adresi, mevcut program sayacı değeri ile komut içindeki sabit değerin toplanmasıyla hesaplanmaktadır.


Bu hesaplamanın komut getirme aşamasında gerçekleştirilmesi, dal tahmininin doğru hedef adresini tek saat çevriminde belirlemesine olanak tanımaktadır. Sabit değer çözümleyici, B tipi dallanma komutları ve J tipi atlama komutları için farklı bit alanlarından değer çıkarmakta ve işaret genişletmesi uygulamaktadır.

Bir dal veya atlama komutu yanlış tahmin edildiğinde, boruhattındaki tüm spekülatif durumun temizlenmesi ve doğru program akışına dönülmesi gerekmektedir. Tasarlanan işlemcide aynı anda üç komut işlenebildiğinden, aynı çevrimde birden fazla yanlış tahmin sonucu oluşabilmektedir. Bu sonuçlar sıra dışı hesaplanmış olsa bile, hızlıca sıraya konularak temizleme işlemine başlanmaktadır.

Gelebilecek olan üç yanlış tahminden en eski olanı dikkate alınmalıdır. Bunun nedeni, daha genç dalların eski dalın spekülatif yolunda bulunabilmesidir. Eski yanlış tahmin düzeltildiğinde, genç dallar zaten temizlenecektir; dolayısıyla genç yanlış tahminleri ayrıca işlemek gereksiz hesaplama yapmak anlamına gelmektedir. Bu önceliklendirme, çoklu getirme birimindeki yanlış tahmin işleme mantığı tarafından gerçekleştirilmektedir: sıfırıncı kanaldan gelen yanlış tahmin birinci ve ikinci kanallara göre önceliklidir, birinci kanaldan gelen yanlış tahmin ise ikinci kanala göre önceliklidir.

Temizleme sinyali etkinleştirildiğinde, program sayacı doğru hedef adresine yönlendirilmekte ve komut tamponu boşaltılmaktadır.

%------------------------------------------------------------------------

\subsection{Program Sayacı Denetleyicisi}\label{subsec:pc_ctrl}

Program sayacı denetleyicisi, bir sonraki getirme adresini belirlemekten sorumlu olan kritik bir bileşendir. Bu birim, çeşitli kaynaklardan gelen bilgileri değerlendirerek program sayacı değerinin nasıl güncelleneceğine karar vermektedir.



Program sayacı güncellemesi, dört farklı senaryoya göre gerçekleşmektedir ve bu senaryolar belirli bir öncelik sırasına göre değerlendirilmektedir.

En yüksek öncelikli senaryo, yanlış tahmin düzeltmesidir. Yürütme aşamasından bir yanlış tahmin sinyali geldiğinde, program sayacı dal kayıt tablosundan alınan doğru adrese yönlendirilmektedir. Bu durum, tüm diğer güncellemeleri geçersiz kılmaktadır çünkü doğru program akışının yeniden kurulması en kritik önceliğe sahiptir.

İkinci öncelikli senaryo, dolaylı atlama tahminlerini içermektedir. JALR komutu için bir tahmin mevcut olduğunda, program sayacı bu tahmin edilen hedef adrese güncellenmektedir.

Üçüncü öncelikli senaryo, doğrudan dallanma ve atlama komutlarını kapsamaktadır. Dallanma veya JAL komutu ``alınacak'' olarak tahmin edildiğinde, program sayacı mevcut değere sabit değerin eklenmesiyle hesaplanan hedef adrese güncellenmektedir.

Dördüncü ve son senaryo, normal ardışık ilerlemedir. Hiçbir dallanma veya atlama komutu tahmin edilmediğinde, program sayacı beş komut için yirmi bayt ileri taşınmaktadır.



Beş komut için program sayacı değerleri paralel olarak hesaplanmaktadır. Her komut için mevcut program sayacı değeri ile dört, sekiz, on iki ve on altı baytlık sabit ofsetler toplanarak ardışık adresler elde edilmektedir. Bu paralel hesaplama, komut getirme işleminin gecikmesini en aza indirmektedir.

Ayrıca, atlama komutları için dönüş adresi değerleri de hesaplanmaktadır. JAL ve JALR komutları, bağlantı yazmacına mevcut komutun bir sonraki adresini kaydetmektedir. Bu değer, program sayacının dört bayt ötesine karşılık gelmektedir.

%------------------------------------------------------------------------

\subsection{Dal Tahmin Sistemi}\label{subsec:branch_pred}

Dal tahmin sistemi, kontrol akışı değişikliklerinin erken tespit edilmesini ve yüksek doğrulukla öngörülmesini sağlamaktadır. Tipik programlarda dallanma ve atlama komutları yüzde on beş ile yüzde yirmi beş arasında bir orana sahiptir \cite{patterson_hennessy}. Etkili bir dal tahmini olmadan, her dal komutu boruhattında birkaç saat çevrimi gecikmeye neden olmaktadır; bu durum işlemci performansını önemli ölçüde düşürmektedir.

Yanlış tahmin cezasının süperölçekli işlemcilere etkisi, skaler işlemcilere kıyasla çok daha yıkıcıdır. Bunun temel nedeni, geniş boruhattında daha fazla spekülatif komutun aynı anda işleniyor olması ve bir yanlış tahmin durumunda tüm bu komutların boşa gitmesidir. Etkin çevrim başına komut değeri ($IPC_{etkin}$), ideal değer ($W$), dallanma oranı ($B$), yanlış tahmin oranı ($M$) ve ceza çevrimi ($P$) cinsinden şu şekilde ifade edilmektedir:

\begin{equation}
    IPC_{etkin} = \frac{W}{1 + W \cdot B \cdot M \cdot P}
    \label{eq:ipc_mispred}
\end{equation}

Bu denklemde $W$ işlemci genişliğini (skaler için 1, üç yollu süperölçekli için 3), $B$ dallanma komut oranını, $M = (1 - Doğruluk)$ yanlış tahmin oranını ve $P$ yanlış tahmin cezası çevrim sayısını ifade etmektedir. Yüzde yirmi dallanma oranı ($B = 0.20$), yüzde seksen tahmin doğruluğu ($M = 0.20$) ve üç çevrimlik ceza ($P = 3$) varsayımlarıyla:

\begin{align}
    IPC_{skaler} &= \frac{1}{1 + 1 \times 0.20 \times 0.20 \times 3} = \frac{1}{1.12} = 0.89 \label{eq:ipc_scalar} \\
    IPC_{super}  &= \frac{3}{1 + 3 \times 0.20 \times 0.20 \times 3} = \frac{3}{1.36} = 2.21 \label{eq:ipc_super}
\end{align}

Verimlilik açısından değerlendirildiğinde, skaler işlemci ideal değerinin yüzde seksen dokuzunu korurken ($\eta_{skaler} = 0.89/1 = \%89$), süperölçekli işlemci yalnızca yüzde yetmiş dördünü koruyabilmektedir ($\eta_{super} = 2.21/3 = \%74$). Bu analiz, süperölçekli mimarilerde dal tahmini doğruluğunun neden kritik öneme sahip olduğunu açıkça ortaya koymaktadır.

Tasarlanan sistemde iki ana tahmin mekanizması bulunmaktadır: koşullu dallanma komutları için iki bitlik sayaç tahmincisi ve dolaylı atlama komutları için JALR tahmincisi.

\subsubsection{Dal Tahmini}

Koşullu dallanma komutlarının yön tahmini için 256 girişli iki bitlik doyurma sayacı tahmincisi kullanılmaktadır. Bu tahminci, program sayacının alt bitlerini indeks olarak kullanarak ilgili sayaç değerine erişmekte ve sayacın en anlamlı bitine göre tahmin üretmektedir. Her sayaç dört durumdan birinde bulunabilmektedir: güçlü alınmayacak (00), zayıf alınmayacak (01), zayıf alınacak (10) ve güçlü alınacak (11).

İki bitlik sayaç kullanımının temel gerekçesi, tek bitlik sayaçların döngü çıkışlarında gösterdiği zayıf performanstır. Bir döngü yüz kez tekrarlandıktan sonra çıkış yaptığında, tek bitlik sayaç hemen yönünü değiştirmekte ve sonraki döngü girişinde yanlış tahmin yapmaktadır. İki bitlik sayaç ise iki ardışık yanlış sonuç gerektirdiğinden bu tür anomali durumlarına karşı dayanıklılık sağlamaktadır \cite{smith_branch}.

Tasarım sürecinde GShare tabanlı turnuva tahmincisi de geliştirilmiş ve test edilmiştir. GShare tahmincisi, program sayacı ile küresel dal geçmişinin XOR işlemiyle indekslenmekte ve daha yüksek doğruluk oranları sunmaktadır \cite{mcfarling}. Ancak bu tahmincinin pratik uygulamasında iki kritik kısıtlama belirlenmiştir. Birinci kısıtlama, kullanılan geliştirme ortamının otomatik bellek çıkarımı yapamaması nedeniyle büyük tabloların flip-flop olarak sentezlenmesidir; bu durum kabul edilemez alan tüketimine ve kritik yolun uzamasına neden olmaktadır. İkinci kısıtlama, büyük tablolara erişimin tek saat çevriminde tamamlanamaması durumunda boruhattı eklenmesi gerekliliğidir; bu ekleme yanlış tahmin cezasını artırmaktadır.

Bu kısıtlamaların etkisini değerlendirmek için iki tahminci senaryosu karşılaştırılmıştır. Gerçekleştirilen simülasyonlarda, iki bitlik sayaç tahmincisi farklı test programları üzerinde ortalama yüzde seksen doğruluk oranına ulaşırken, GShare tahmincisi ortalama yüzde seksen üç doğruluk oranı sergilemiştir. Bu değerler çalıştırılan uygulamanın dallanma karakteristiklerine bağlı olarak değişkenlik gösterebilmektedir. Birinci senaryoda 256 girişli iki bitlik sayaç tahmincisi üç çevrimlik yanlış tahmin cezası ile kullanılmaktadır. İkinci senaryoda 4096 girişli GShare tahmincisi kullanılmakta, ancak boruhattı nedeniyle dört çevrimlik yanlış tahmin cezası uygulanmaktadır. Dallanma oranı $B = 0.20$ ve işlemci genişliği $W = 3$ varsayımlarıyla IPC değerleri aşağıdaki şekilde hesaplanmıştır:


\begin{align}
    IPC_{basit} &= \frac{3}{1 + 3 \times 0.20 \times 0.20 \times 3} = \frac{3}{1.36} = 2.21 \label{eq:ipc_simple} \\
    IPC_{gshare} &= \frac{3}{1 + 3 \times 0.20 \times 0.17 \times 4} = \frac{3}{1.41} = 2.13 \label{eq:ipc_complex}
\end{align}

Hesaplamalar, GShare tahmincisinin sağladığı yüzde üçlük doğruluk artışının, artan yanlış tahmin cezasını telafi edemediğini göstermektedir. Bu sonuç doğrultusunda, daha küçük alan maliyeti ve daha düşük yanlış tahmin cezası sunan iki bitlik sayaç tahmincisi tercih edilmiştir.

\subsubsection{JALR Tahmini}\label{subsubsec:jalr}

Dolaylı atlama komutları, hedef adresini bir yazmaçtan okuduğundan derleme zamanında bilinmemektedir. Bu nedenle JALR komutları için ayrı bir tahmin mekanizması gerekmektedir. JALR tahmincisi JALR hedef tamponu ve dönüş adresi yığını olmak üzere iki temel bileşenden oluşmaktadır.

JALR hedef tamponu, daha önce yürütülen JALR komutlarının hedef adreslerini saklayan bir önbellek yapısıdır. Bu yapı, program sayacı değerine göre indekslenmekte ve son kullanılan hedef adresi döndürmektedir. Birçok dolaylı atlama, özellikle sanal fonksiyon çağrıları ve anahtarlama ifadeleri, aynı hedef adrese tekrar tekrar atladığından bu yaklaşım yüksek doğruluk sağlamaktadır.

Tasarlanan sistemde JALR hedef tamponu otuz iki giriş kapasitesine sahiptir. Her giriş geçerlilik biti, etiket değeri ve hedef adres içermektedir. Etiket karşılaştırması, farklı JALR komutlarını ayırt etmek için kullanılmaktadır.

Dönüş adresi yığını, fonksiyon çağrısı ve dönüş kalıplarını tahmin etmek için özelleştirilmiş bir yapıdır. Fonksiyon çağrılarının çoğunluğu çağrı ve dönüş çiftleri şeklinde gerçekleşmektedir; bu durum son giren ilk çıkar yapısıyla doğal olarak eşleşmektedir.

RISC-V mimarisinde çağrı ve dönüş komutları, hedef veya kaynak olarak x1 veya x5 yazmaçlarını kullanan JAL ve JALR komutları ile gerçekleştirilmektedir. Çağrı komutu tespit edildiğinde, dönüş adresi yığına itilmektedir; dönüş komutu tespit edildiğinde ise yığından çekilmekte ve hedef adres olarak kullanılmaktadır.

Tasarlanan sistemde dönüş adresi yığını sekiz giriş derinliğindedir. Spekülatif yürütmeyi desteklemek için, her dal tahmini sırasında yığın tepe işaretçisi dal kayıt tablosuna kaydedilmekte ve yanlış tahmin durumunda geri yüklenmektedir.

%------------------------------------------------------------------------

\subsection{Komut Tamponu}\label{subsec:instr_buffer}

Komut tamponu, komut getirme ve kod çözme aşamaları arasında ayrıştırma sağlayan bir ilk giren ilk çıkar yapısıdır. Bu ayrıştırma, her iki aşamanın farklı hızlarda çalışmasına olanak tanımakta ve boruhattı verimliliğini artırmaktadır.


Komut getirme aşaması dallanma ve atlama komutları nedeniyle, boruhattının ileri aşamaları ise veri bağımlılıkları, bellek işlemleri ve daha birçok sebeple farklı hızlarda çalışabilmektedir. Komut belleğinden komutları hızlıca alıp bunları boruhattının ileriki aşamalarının kullanabileceği şekilde bir tamponda toplamak, işlemcinin karmaşıklığını azaltmakla birlikte performansını da artırmaktadır.

Ayrıca, komut verme aşaması duraklatıldığında komut getirme aşaması tampon dolana kadar çalışmaya devam edebilmektedir. Bu yalıtım, kısa süreli duraksamaların boruhattının tamamını etkilemesini engellemektedir.



Komut tamponu, baş ve kuyruk işaretçileri ile yönetilen dairesel bir tampon olarak gerçeklenmiştir. Varsayılan tampon derinliği on altı giriştir ve bu değerin ikinin kuvveti olması zorunludur; bu gereksinim modüler aritmetik işlemlerini basitleştirmektedir.

Her tampon girişi çeşitli bilgiler içermektedir: otuz iki bitlik komut verisi, tahmin anındaki program sayacı değeri, tahmin edilen sonraki program sayacı değeri, dal tahmini sonucu, dönüş adresi yığını tepe işaretçisi değeri. Bu bilgiler, komutun sonraki aşamalarda doğru bir şekilde işlenmesi için gereklidir.


Geri baskı mekanizması, tamponun dolması durumunda komut getirme aşamasını yavaşlatarak veri kaybını önlemektedir. Tamponda en az beş boş alan bulunduğunda, getirme hazır sinyali etkinleştirilmektedir. Beş alan gereksinimi, tek çevrimde gelebilecek maksimum komut sayısını karşılamak için belirlenmiştir.

Beşten az boş alan bulunduğunda komut ekleme işleminin gerçekleştirilmesi, sonraki komut adresinin hesaplanmasını karmaşıklaştıracaktır. Mevcut tasarımda bu karmaşıklıktan kaçınılarak adres hesaplama mantığı basit tutulmuştur.
